I've managed to make the client and server sockets work for/with multiple clients, and that allows me to deal with some problems.

So basically, I originally used the template provided by the SFML examples to constrcut a basic server and client, but I've gone and separated into 2 different files, client and server. Doing this I've also been able to take out the necessesity of an extra thread in the server, and it has been used somewhere else (for listening to new connections). And then I realised I needed to transmit data (such as usernames) to the sever, so I used # as a delimiter to separate them, and replaced other #'s used in the message as {hash} which I made the server go over and then put back into # for outputting the message. However I realised this would require a better solution in the future, as { and } have had to be put down as reserved characters.
Then I realised that I needed to make it so that a client can disconnect without leaving the server continuously listening on that port, so I made a std::vector<sf::TcpSocket*> to store the active connections and then iterate through them to check if they have disconnected. I also used this to check if they had sent a message, and output that when needed.

Then I came across my first actual unintentional bug, which is when I tried to send messages on windows to the server which is on linux.
I was getting std::length_error, and I couldn't find what was wrong, so I thought that it might be worth a try to convert the string to a C style string (char array) and then send it using string.c_str(), which actually worked, and I figure it must've been that it was a platform issue, and as C strings are much more universal, that is why it was solved.
Then I came across another problem, how would I store my data in files? I came to the conclusion that an actual database is not needed, so instead I've opted to use a .csv file, comma separated values, which should be pretty easy to manage. And, if need be, I can add a file for indexes of the file, and other details for faster access (albeit some overhead).
